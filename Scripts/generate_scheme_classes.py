#!/usr/bin/env python3
"""
Generate *_Scheme.cs files from existing palette files that still
contain the `_schemeBaseColors` array.

Usage (run from repo root):

    python Scripts/generate_scheme_classes.py [--dry-run]

The script will:
1. Parse `PaletteEnumerations.cs` to get the ordered list of
   `SchemeBaseColors` names.
2. Walk all *Palette* files under
   `Source/Krypton Components/Krypton.Toolkit/Palette Builtin/` looking
   for `private static readonly Color[] _schemeBaseColors`.
3. Extract colour expressions in the array (expression portion before
   `//`).  The index determines the enum the colour belongs to.
4. Create a `PaletteXXXScheme.cs` file **next to** the palette file with
   a class deriving from `AbstractBaseColorScheme` that implements all
   properties.
   * Missing colours default to `GlobalStaticValues.EMPTY_COLOR`.
5. Palette files **are left untouched**; you still need to:
   – remove the array manually (or keep it)
   – add a static instance and pass it to the base constructor.

Options
-------
--dry-run   Only print what would be generated.

The script is idempotent: it skips generation if the target file already
exists.
"""

import argparse
import os
import re
import sys
from pathlib import Path

# ---------------------------------------------------------------------------
# Config
# ---------------------------------------------------------------------------
ROOT = Path(__file__).resolve().parents[1]
BASE_DIR = ROOT / "Source" / "Krypton Components" / "Krypton.Toolkit" / "Palette Builtin"
ENUM_FILE = BASE_DIR / "Enumerations" / "PaletteEnumerations.cs"
ARRAY_MARKER = "private static readonly Color[] _schemeBaseColors"

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def parse_enum_names() -> list[str]:
    pattern_start = re.compile(r"\benum\s+SchemeBaseColors\b")
    enum_names: list[str] = []
    inside = False
    with ENUM_FILE.open(encoding="utf-8") as f:
        for line in f:
            if not inside:
                if pattern_start.search(line):
                    inside = True
                continue
            # inside enum
            if "}" in line:
                break
            if line.strip().startswith("//"):
                continue
            m = re.match(r"\s*([A-Za-z0-9_]+)\s*([,=]|$)", line)
            if m:
                enum_names.append(m.group(1))
    return enum_names


def collect_palette_files() -> list[Path]:
    result: list[Path] = []
    for p in BASE_DIR.rglob("*.cs"):
        if p.name.endswith(".Designer.cs"):
            continue
        try:
            txt = p.read_text(encoding="utf-8")
        except UnicodeDecodeError:
            continue
        if ARRAY_MARKER in txt:
            result.append(p)
    return result


def extract_color_expressions(palette_path: Path) -> list[str]:
    """Return list of raw Color expressions in declaration order."""
    lines = palette_path.read_text(encoding="utf-8").splitlines()
    start = None
    for idx, line in enumerate(lines):
        if ARRAY_MARKER in line:
            start = idx
            break
    if start is None:
        return []
    colors: list[str] = []
    current = ""
    paren_balance = 0  # track '(' vs ')'

    def flush_current():
        nonlocal current, paren_balance
        if current:
            expr = current.strip().rstrip(',')
            if expr:
                colors.append(expr)
        current = ""
        paren_balance = 0

    for line in lines[start + 1:]:
        if "]" in line and current == "":  # reached end of array
            break

        code_part = line.split("//", 1)[0].strip()
        if not code_part or code_part in {"[", "]"}:
            continue

        # accumulate expression lines
        if current:
            current += " " + code_part
        else:
            current = code_part

        # update parenthesis balance
        paren_balance += code_part.count('(') - code_part.count(')')

        # when balance is zero and line ends with ',' or ')', expression complete
        if paren_balance == 0:
            flush_current()

    flush_current()
    return colors


def make_class_name(palette_path: Path) -> str:
    # PaletteMicrosoft365Black.cs -> PaletteMicrosoft365BlackScheme
    base = palette_path.stem  # without ".cs"
    return f"{base}Scheme"


def generate_scheme_code(class_name: str, colors: list[str], enum_names: list[str],
                         namespace: str = "Krypton.Toolkit") -> str:
    total = len(enum_names)
    # ensure list length
    if len(colors) < total:
        colors = colors + ["GlobalStaticValues.EMPTY_COLOR"] * (total - len(colors))
    header = """#region BSD License
/*
 * Auto-generated by generate_scheme_classes.py – DO NOT EDIT MANUALLY
 */
#endregion

namespace {namespace};

public sealed class {class_name} : AbstractBaseColorScheme
{{
""".format(namespace=namespace, class_name=class_name)

    props = []
    indent = " " * 4
    for name, expr in zip(enum_names, colors):
        props.append(f"{indent}public override Color {name} => {expr};")

    body = "\n".join(props)
    code = f"{header}{body}\n}}\n"
    return code

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    argp = argparse.ArgumentParser(description="Generate *Scheme.cs classes for Krypton palettes")
    argp.add_argument("--dry-run", action="store_true", help="Preview actions without writing files")
    argp.add_argument("--single", action="store_true", help="Generate scheme for the first eligible palette only")
    args = argp.parse_args()

    enum_names = parse_enum_names()
    if not enum_names:
        print("Failed to parse enumeration names from", ENUM_FILE, file=sys.stderr)
        sys.exit(1)

    palette_files = collect_palette_files()
    print(f"Found {len(palette_files)} palette files with _schemeBaseColors")

    for palette in palette_files:
        colors = extract_color_expressions(palette)
        if not colors:
            continue
        class_name = make_class_name(palette)
        scheme_cs_path = palette.with_name(f"{class_name}.cs")
        if scheme_cs_path.exists():
            print(f"Skip {scheme_cs_path.name} (already exists)")
            continue
        code = generate_scheme_code(class_name, colors, enum_names)
        if args.dry_run:
            print(f"Would create {scheme_cs_path.relative_to(ROOT)}")
        else:
            scheme_cs_path.write_text(code, encoding="utf-8")
            print(f"Created {scheme_cs_path.relative_to(ROOT)}")

        if args.single:
            break

if __name__ == "__main__":
    main()