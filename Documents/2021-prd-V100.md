# Standard-Toolkit Theme Refactor – 2021 PRD

## Purpose

Provide a clear, actionable plan for migrating built-in themes to the new colour-scheme abstraction
and embedded-resource delivery while adding missing palette functionality.

## Scope

1. Move all frozen built-in themes into a dedicated resource assembly.
2. Adopt `AbstractBaseColorScheme` and generated `Palette*Scheme.cs` for every theme.
3. Equip `KryptonCustomPaletteBase` (KCPB) with the remaining features required for custom themes.
4. Supply adaptors, transitional APIs and tooling to minimise update effort.
5. Remove obsolete or insecure code paths.

## Phased Task List

### Phase 1 – Foundation (highest priority)

1. **Create new assembly `Krypton.Toolkit.Themes`**

   - Project type: Class Library targeting .NET 4.7.2.
   - Reference `Krypton.Toolkit` only.
   - The `.csproj` **must** multi-target the same set of conditional TFMs as `Source/Krypton Components/Krypton.Toolkit/Krypton.Toolkit 2022.csproj` (currently `net462;net472;net48;net6.0-windows;net7.0-windows;net8.0-windows;net10.0-windows`). Replicate `TargetFrameworks`, the `UseWindowsForms` property, `GenerateAssemblyInfo`, nullable/context settings and the common `Directory.Build.props` imports so the Themes DLL compiles identically across all supported platforms.
   - Add MSBuild task to embed each theme `.xml` or `.bin` under `Resources/Themes/<name>.kpt`.

2. **Move physical palette classes**

   - Copy each current built-in palette class to the new assembly _without modification_.
   - Mark originals `[Obsolete("Moved to Krypton.Toolkit.Themes")]` and delegate to new types.

3. **Wire resource loader**

   - New static class `ThemeStore` in the Themes assembly exposing:

     ```csharp
     IEnumerable<string> ListNames();
     Stream OpenTheme(string name);
     PaletteBase LoadTheme(string name); // lazy-loads and caches
     ```

4. **Update `KryptonManager`**

   - Overload `GlobalPaletteMode` setter to accept an enum value backed by `ThemeStore`.
   - Preserve existing behaviour for historic modes.

5. **Generate `Palette*Scheme.cs` files**

   - Run `generate_scheme_classes.py` for every palette in the themes assembly.
   - Delete legacy `_ribbonColors` arrays once verified.
   - Ensure palette constructors use the new scheme overload.
   - The generated classes can remain as the **vanilla** colour tables; when a theme is loaded from XML the loader will overwrite the corresponding `AbstractBaseColorScheme` properties with the values read from file. This keeps the C# sources simple while honouring colour customisations at runtime.

6. **Regenerate colour tables**

   - Set `Table = null` once after scheme injection to force rebuild.

### Phase 2 – Low-Hanging Fruit (optional; independent, quick wins)

1. **Implement missing `GetContentImageColorTransparent` and similar TODOs** (replace `throw new NotImplementedException`).
2. **Remove `BinaryFormatter` fallback** in `ImportImagesFromElement` and replace with PNG-only deserialisation.
   - Provide a **one-off** converter command in the new `kptheme` tool (`kptheme fix-images <file>`), capable of deserialising the legacy binary-formatted images and rewriting the palette XML with PNG blocks. The library itself must contain **zero** references to `BinaryFormatter`.
3. **Complete type maps** in `TypeToString` / `StringToType`:
   - Add `Size`, `Point`, `Rectangle`, `ContentAlignment`, `DockStyle`, any new enums.
4. **Mark obsolete APIs**
   - `[Obsolete("Use ThemeStore.LoadTheme")]` on direct palette constructors in application examples.

### Phase 3 – Transitional Adaptors

1. **Adaptor constructors**
   - For each existing palette class in main assembly, add `internal` ctor taking a resource stream and forwarding to Themes assembly counterpart.
2. **`PaletteWrapper` helper**
   - Small class deriving from `KryptonCustomPaletteBase` that calls `PopulateFromBase` with a supplied built-in palette instance.
3. **Compile-time shim**
   - `using LegacyTheme = Krypton.Toolkit.Themes.XYZPalette;` for source compatibility in test projects.

### Phase 4 – Tooling

1. **Port the scheme-generator to C#**
   - Create a new project `Krypton.ThemeGen` (class-library) that re-implements the functionality of `generate_scheme_classes.py`.
   - Public API: `SchemeGenerator.Generate(string paletteClass, string outputFolder, bool embedResx)`.
   - Expose MSBuild task `GenerateSchemeClasses` so the Themes assembly can auto-generate classes during build (supports `/p:EmbedResx=true`).

2. **`kptheme` dotnet-tool**
   - Console app referencing `Krypton.ThemeGen` for all generation logic.
   - Commands:
     - `list` – list embedded themes.
     - `export <name> <path>` – write theme xml to disk.
     - `import <file>` – validate and add to user store.
     - `genscheme <paletteClass>` – invoke `SchemeGenerator` and write `Palette*Scheme.cs` (honours `--embed-resx`).
     - `fix-images <file>` – convert legacy binary-serialised `<Image>` blocks to PNG and update the XML in-place. During conversion, any duplicate PNGs are automatically de-duplicated as described below.

   - **Automatic Image De-duplication**: While generating or converting a theme, the tool computes SHA-256 hashes for every bitmap.  Identical hashes are stored once in `SharedImages.resx` and referenced via `<ref name="hash.png" />` in the emitted XML or RESX. This prevents the same bitmap from being embedded multiple times across themes.

3. **Optional CI safeguard**
   - (Optional) Add a GitHub workflow that runs `kptheme genscheme --check`. The job should **report** (via warnings/annotations) any palettes that still embed legacy colour–array fields such as `_ribbonColors` (or variants detected via simple regex). It must **not** fail the build; it is purely informational so maintainers can track outstanding migration work.
   - Enable this workflow only **after** all Phase-1 groundwork has landed.
   - Runner image: `runs-on: windows-2022` (or `windows-latest`, currently mapped to 2022) because GitHub has removed the Windows Server 2019 runner.

### Phase 5 – Cleanup

1. Remove dead code (`ImageDictionary` reverse look-ups unused after BinaryFormatter removal).
2. Document public API changes in CHANGELOG.

## Deliverables

- `Krypton.Toolkit.Themes.dll` containing all embedded themes and scheme classes.
- Updated `Krypton.Toolkit` with loader, adaptors, completed serialization and no obsolete code paths.
- New `kptheme` CLI and removal of Python helper script.
- Detailed migration guide (to be written in a follow-up doc).

## Milestones & Estimations (ideal-day)

| Phase | Effort | Owner |
|-------|--------|-------|
| 1 | 4-5 days | Core maintainer |
| 2 | 1-2 days | Any contributor |
| 3 | 1 day | Core maintainer |
| 4 | 2-3 days | Tooling volunteer |
| 5 | 1 day | Core maintainer |

## Risks

- Theme loading performance – mitigate with lazy caching.
- Binary compatibility – addressed via adaptor constructors and obsoletes.
- Large resource sizes – compress `.kpt` files if needed.

## Acceptance Criteria

1. `KryptonManager.GlobalPaletteMode = GlobalPaletteMode.Microsoft365Black` loads from Themes assembly.
2. Sample app toggles themes without referencing physical palette classes.
3. `generate_scheme_classes.py` passes with no missing colours.
4. All unit tests compile without warnings.
5. No `BinaryFormatter` usage remains in the codebase.
6. **TestForm Showcase**
    - The existing `Source/Krypton Components/TestForm` WinForms project builds and runs against the new `Krypton.Toolkit.Themes.dll`.
    - Manual smoke-test: using the TestForm UI the tester can switch between at least three embedded themes (e.g. _Microsoft365Black_, _Office2010Silver_, _SparkleBlue_).  All major controls ‑ Navigator, Ribbon, Docking, Grid, Calendar, Input controls ‑ render without exceptions and adopt the selected theme immediately.
    - Optional automated check: a simple UIAutomation script (or WinAppDriver test) starts TestForm, clicks the theme switcher, asserts that the form background colour changes and that no first-chance exceptions appear in the debug output.
